---
layout: post
title:  "HOW TO IMPLEMENT A 1:N RELATIONAL MODEL IN DJANGO 1.9"
date:   2016-03-11
---

<p class="intro">
One of the most common 1:N relational models is the “Post” – “Comment” model.
</p>

In this article, I would like to log the process of myself implementing the comment model onto a post. (The views will be rendered using the function-based view, not the class-based view and I promise to make it quick and easy)

I currently have the videos and video function view implemented. The videos function renders a function that gives the view for the whole video list. The video function renders a detail video page for one image. Also, I have the Video model, which has the field of the title of the video, the content of the video(in text), and the url of the video.

Lets start off by implementing the comment model.

{% highlight python %}
from django.db import models

class Video(models.Model):

    title = models.CharField(
        max_length=20, 
    )
    content = models.TextField()
    video_url = models.URLField(
        max_length=200,
    )

class Comment(models.Model):
        video = models.ForeignKey("Video")
        content = models.TextField()
{% endhighlight %}

Suprisingly, this short 2 line of code is enough for the “Comment class” implementation. By using the ForeignKey method and putting in “Video” which is pretty straight forward, the Comment class now a 1:N relational model with the “Video” model.

How, in python code, do we access the comment model?

Easy.

Now because the comment has a 1:N relation with the video model, we can access(CRUD) by accessing the methods that are inside the Video model. No need to deal with the Comment model directly. Django automatically makes an method called object comment_set(if we named it some other random name it a method such as random_name_set would be generated by django) and inside it there is a create method. So inside the comment view function, it will be look something like this:

{% highlight python %}
    def comment(request, pk):

    if request.method=="POST":
        video = Video.objects.get(pk=pk)

        content = request.POST.get("content")
        video.comment_set.create(content=content)

        return redirect(
            reverse(
                "video",
                kwargs={"pk":video.id,}
            )
        )
{% endhighlight %}

Pretty simple, heh?
If we get a POST request within the video view, we retrieve the id(pk) of the video and retrieve it using the manager ‘objects’.
After getting the content from the POST request, we store it in a comment model by doing:

{% highlight python %}
        video.comment_set.create(content=content)
{% endhighlight %}

Then we redirect the view to the video view to show the updated comments.

Now we are almost done. Lets finish off with making modifications in the urls.py file.

{% highlight python %}
from feature_video.views import videos, video

urlpatterns = [
    # videos is a function that renders the video lists and is located at feature_video/views.py
    url(r'^videos/$', videos, name="videos"),
    # video is a function that renders the detail video page and is located at feature_video/views.py
    url(r'^videos/(?P<pk>\d+)/$', video, name="video"),
    # this url will provide the route for when a comment is POSTed in a detail video view
    url(r'^videos/$(?P<pk>\d+)/comments$', comments, name="comments"),  
]
{% endhighlight %}

Thanks to Django, creating a Post & Comment-to-Post model was seriously that easy!
